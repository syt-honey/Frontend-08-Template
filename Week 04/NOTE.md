## 字符串匹配算法

### 一、字典树算法

#### （1）介绍

下面是 wiki 对[字典树的介绍]((https://zh.wikipedia.org/wiki/Trie) )：
> 在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

一般来说，我们可以这样认为：字典树这个数据结构和我们知道的字典一样，将所有的字符串根据 26 个字母来分组。比如，所有 `a` 开头的字符串都在 `a` 这个节点下面。

假设现在要存储的单词是 `at` 。那这个单词的存储其实就是在 `a` 节点下生成一个 `t` 节点（如果 `a` 下已经有了 `t` 节点，那需要做一点点小小的记录）。

> 注：上面说的' 26 个字母来分组'并不是一定的。这要看所有的字符串的首字母的种类。

下面是一个保存了 8 个键的 trie 结构，"A", "to", "tea", "ted", "ten", "i", "in", "inn"。

![Trie](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd8a0596514947d4ba22d6310d6d2822~tplv-k3u1fbpfcp-watermark.image)

> 注：该图来自 wiki，存储于掘金。

#### （2）使用场景

根据上面的介绍我们可以看出，字典树在字符串查找的速度上是有先天优势的。由于插入的时候已经分好了组，查询的时间复杂度是常量级别的 O(k)。其中 k 为 key 的长度。基于结构上的优势，使用 Trie 算法可以最大限度减少无谓字符的比较。以下就是它常用的场景：

* 词频统计
* 前缀匹配

在代码中，我们就实现了一个在随机生成的字符串序列中查找重复次数最多的字符串。

### 二、KMP 匹配算法

#### （1）介绍

KMP 算法相当于是暴力匹配算法的一个升级。暴力匹配算法在最差的情况下时间复杂度是 O(m * n)，为了解决这个问题，KMP 算法提高了模式匹配的效率。

在介绍 KMP 算法之前我们需要先介绍一下 4 个概念：`字符串的前缀` 是指，字符串去掉最后一个字符后，该字符串的所有头部字符串的集合。`字符串的后缀` 定义与 `字符串前缀` 相似，不再赘述。`前后缀相同元素长度` 是指，字符串的所有前缀和后缀字符中每个字符都有相同的长度。`next 数组`指的是模式串匹配失败字符之前的字符串的前后缀相同元素长度，因第一个字符前没有其他字符，所以规定 next 数组的第一位值为 0，同理 next 数组的第二位值也为 0。

在一开始时，它们的匹配方式是相同的。但是当在某个字符失配后，模式串就需要向右移动，移动的位数等于模式串匹配成功的字符数减去模式串匹配成功字符串的前后缀相同元素长度。然后再从模式串中前后缀相同元素的后一位与对应位的目标串字符进行对比。

上面是 KMP 算法的原理，下面我们通过一个具体的例子看看：

下图中，当第一趟匹配失败后，发现模式串失配前的字符串是 `ABDAB`，它的长度为5，前后缀相同元素是AB，并且长度为2，因此模式串向右移动三位，然后再次与目标串进行比较，并且此时只需要从模式串的第三位字符开始与目标串对应位的字符进行对比。

![KMP](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42472c566bd94e6ba43817ba5808c69c~tplv-k3u1fbpfcp-watermark.image)

#### （2）核心思想

### 三、wildcard 算法

#### （1）介绍

### （2）核心思想

### 四、练习点

* 字符串匹配算法
* 选择器
* css 实现标签导航
* css 实现 loading